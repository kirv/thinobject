#!/bin/bash

# tob -- thinobject 'enabler' program
# Copyright (C) 2010 Ken Irving
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

warn () {
    test -n "$QUIET" && return
    printf "%s\n" "$@" >&2
    }

error () {
    # synopsis: error [-x N] OUTPUT_LINE ...
    local -i n=1
    test "$1" = -x && n=$2 && shift 2
    warn "$@"
    exit $n
    }
export -f error

debug () {
    test -n "$DEBUG" || return
    printf "DEBUG:" >&2
    printf "\t%s\n" "$@" >&2
    }

resolve_library () {
    for lib in ${TOBLIB/:/ }; do
        test -d $lib/$1 && path=$lib/$1 && return
    done
    return 1
    }

resolve_search_paths () { # resolve (proto)type(s) into types[], apaths[], mpaths[]
    local type=$1 && shift
  # warn " " "    RESOLVE: $type"
    local path
    shopt -s nullglob
    while test -n "$type"; do
      # warn "        CHECKING: $type"
        if test -d "$type"; then
            # ... a 'prototype' only provides attributes, not methods
            path=$type
            apaths+=($path)
        else
            resolve_library $type || return 1
            types+=($type)
            apaths+=($path)
            mpaths+=($path)
        fi
        unset type
      # warn PATH: $path

        for mixin in $path/{,.}^?*; do # ... e.g., ^Cron or .^settings, etc.
          # warn MIXIN: $mixin
            test -z "$TOB_NO_MIXINS" || break
            test -L $mixin || continue # ... skip if not a symlink

            if test -d $mixin; then # ... prototype object
                mixin=$(readlink $mixin)
                if test ${mixin:0:1} = /; then # ... absolute path
                    resolve_search_paths $mixin
                else
                    resolve_search_paths $path/$mixin
                fi
            else # does not resolve, so assume it's a type
                resolve_search_paths $(readlink $mixin)
            fi
        done

        test -n "$1" && type=$1 && shift && continue # ... use arg for type
        test -L $path/^ && type=$(readlink $path/^)
        test -L $path/.^ && type=$(readlink $path/.^)
    done
    cull_duplicate_paths
    test -n "$apaths[*]" || return 1
    test -n "$mpaths[*]" || return 2
    }

resolve_declaration () { 
    #   synopsis: resolve_declaration path object
    #   return 0 if declaration found and type identified
    #   return 1 if no declaration found
    local path=$1 object=$2 p
    for p in "${apaths[@]}"; do
        for symvar in $p/$object $p/.$object; do
            test -L $symvar -a ! -e $symvar || continue
            type=($(readlink $symvar))
            test -n "$type" && test ${type:0:1} != '=' && return
        done
    done
    return 1
    }


resolve_query () { # try to resolve path, object, type, and method from query
    debug "QUERY $1"
    local -a query=${1//\//\/.}         # change all / to /. for splitting ...
    debug "QUERY ${query[@]}"
    query=(${query//./ })               # split on dot into array
    debug "QUERY ${query[@]}"
    test ${query:0:1} = / && path='' || path=.
    local -i i p=0 n=${#query[*]} m=n-1
    debug "n $n" "m $m"
    # analyze query from left to identify directories in variable path:
    for (( i=0; i<n; i+=1 )); do 
        dir="${query[*]:i-p:p+1}"       # p previous elements + element i
        dir=${dir// /.}                 # change "a b" to "a.b"
        test -d $path/$dir && path+=/$dir && p=0 && continue
        test ${dir: -1:1} = / && return 1
        test -d $path/.$dir && path+=/.$dir && p=0 && continue
        p+=1
    done
    # set i to point to element just past path portion, the object + method:
    i=n-p

    # existing attribute search path is useful only if path is .
    test -n "${apaths[*]}" -a $path != . && apaths=()

    # look for object or .object in the attribute search paths for path:
    # obtain attribute search paths for the query path object:
    test -n "${apaths[*]}" || resolve_search_paths $path || {
        test $? -eq 1 && return 1
        }

    # work right to left from all-object + no-method to no-object + all-method
    # m will start at the last query element, then decrement on each pass
    # object is extracted from query[i] to query[m], using dot separator
    local -i m
    for (( m=n-1; m>=i; m+=-1 )); do
        # index m points to last element of object in query
        object="${query[*]:i:m-i+1}"
        object=${object// /.}
        resolve_declaration $path $object && {
            # success, so what is the method...?
            method="${query[*]:m+1}"
            method=${method// /.}
            test -n "$method" || method=default
            TOB_path_to_object=$path
            return
            }
    done

    # if $path itself is a dir object with a ^ link, we're done:
    test -L $path/^ -o -L $path/.^ && {
        type=$(readlink $path/^ || readlink $path/.^)
        method="${query[*]:i}"
        method="${method// /.}"
        cd $path || return 2
        TOB_path_to_object=$path
        TOB_method=$method
        }

    }


cull_duplicate_paths () {
    local entry unique
    local -i i
    # arrays types and mpaths are 1:1, so scan types, discard from both
    for (( i=${#types[@]}; i>=0; i-- )); do
        entry=${types[$i]}
        test "${unique/$entry/}" = "$unique" || {
            # this entry already scanned
            unset types[$i]
            unset mpaths[$i]
            continue
            }
        unique+=" $entry"
    done
    unique=
    # apaths array can include duplicates, so scan & discard, leaving last
    for (( i=${#apaths[@]}; i>=0; i-- )); do
        entry=${apaths[$i]}
        test "${unique/$entry/}" = "$unique" || {
            # this entry already scanned
            unset apaths[$i]
            continue
            }
        unique+=" $entry"
    done
    }

resolve_method_path () {
    local method=$1
    declare -i super=0
    while test "${method:0:6}" = super.; do
        method=${method:6}
        super+=1
    done
    for path in ${mpaths[@]}; do
        test -x $path/$method && {
            test -n "$super" -a "$super" -gt 0 && super+=-1 && continue
            TOB_method_path=$path/$method
            return
            }
    done
    return 1
    }



TOB_resolve_method_path () {
    local method=$1
    local -i super=0
    echo looking for $method >2
    while test "${method:0:6}" = "super."; do
        method=${method:6}
        super+=1
    done
    for path in ${TOB_method_paths//:/ }; do
        test -x $path/$method && {
            test $super -gt 0 && super+=-1 && continue
            TOB_method_path=$path/$method
            return
            }
    done
    return 1
    }

TOB_get_attr () {
    # set variable 'attr' to attribute value(s), or return false
    # if $arg matches a file, scalar attr is set to its contents
    # if file(s) matches $arg=value, array attr is set to value(s)
    local arg=$1 path file
    test -n "$arg" || return 1
    for path in ${TOB_search_paths//:/ }; do
        test -e "$path/$arg" && attr=$(<$path/$arg) && return
        file=($path/$arg=*)
        test "${file: -1}" = '*' && continue
        attr=(${file[@]#$path/$arg=}) && return
    done
    return 1
    }

main () {
    test -n "$TOBLIB" || error -x 102 "TOBLIB is not set"
    declare path= object= method= 
    declare -a opts=() args=() types=() mpaths=() apaths=() envars=()
    while test "${1:0:1}" = -; do # process option...
        case $1 in
            -q | --quiet)       QUIET=1;        opts+=(-q) ;;
            -v | --verbose)     VERBOSE=1;      opts+=(-v) ;;
            -d | --debug)       DEBUG=1;        opts+=(-d) ;;
            -h | --help)        exec awk '/^NAME$/,0' $0 ;;
            -a | --arg)         args+=($2) && shift ;;
            -m | --method)      method="$2" && shift
                                test -n "$method" ||
                                    error -x 101 "no method argument" ;;
            *) error -x 102 "unsupported option: $1" ;;
        esac
        shift
    done
    test -n "$DEBUG" || alias debug=\#

    test -n "$method" && method_option "$@"  # ... will not return!

    test ${#args[*]} -eq 0 ||
        error -x 102 "--arg option used without --method option"

    test -n "$1" || error -x 103 "no object specified"
    
    declare qry=$1 && shift # expecting OBJECT.METHOD

    # if no dot is found, exec as self.method, where self is current dir
    test ${qry#.} = $qry &&
        exec $0 "${opts[@]}" ..$qry "$@"

    declare -x TOB_caller_path=$PWD

    resolve_query $qry || exit

    debug "path: $path" "object: $object" "method: $method" "args: $*"
    debug "type and envars:" ${type[*]}
   
    debug "TOB_path_to_object: $TOB_path_to_object"
    
    types=() mpaths=() apaths=() envars=()

    # resolve_search_paths() builds arrays: types and paths, recursing on mixins
    # - first of 2 args is the object, not class, may include mixins
    # - types array is 1:1 with path after skipping paths[0]
    if test -n "${attr[*]}"; then
        unset attr[0]   # this is type, any other entries are envars
        resolve_search_paths $type
        object=$TOB_path_to_object
    else
        unset attr[0]   # this is type, any other entries are envars
        resolve_search_paths . $type
    fi

    debug "${#types[*]} TYPES:" "${types[@]}"
    debug "${#mpaths[*]} MPATHS:" "${mpaths[@]}"
    debug "${#apaths[*]} APATHS:" "${apaths[@]}"
    
    test -n "$types" || {
        test "${#apaths[@]}" -gt 1 &&
            error -x 120 "prototype but no type resolved for $object"
        error -x 121 "no type or prototype resolved for $object"
        }

    test "$types" || {
        test "${#apaths[@]}" -gt 1 &&
            error -x 120 "prototype but no type resolved for $object"
        error -x 121 "no type or prototype resolved for $object"
        }

    ## export thinobject variables
    export TOB_object=$object
    export TOB_method=$method
    export TOB_type=$type
    export TOB_class_path
    export TOB_caller_path
    export TOB_caller_path_to_object=$TOB_path_to_object
    
    ## export thinobject utility functions and associated variables:
    export -f TOB_resolve_method_path
    export TOB_method_path
    export -f TOB_get_attr
    
    # create pseudo-arrays for export, with colon as delimiter:
    save_IFS="$IFS"
    IFS=:
    export TOB_search_paths="${apaths[*]}"
    export TOB_method_paths="${mpaths[*]}"
    export TOB_type="${types[*]}"
    IFS="$save_IFS"
    
    for envar in "${attr[@]}"; do
        tag=${envar%%=*}
        test $tag = $envar && continue
        val=${envar#*=}
        export $tag=$val
    done
    
    resolve_method_path $TOB_method && {
        debug "exec $TOB_method_path ${args[*]} $*"
        exec $TOB_method_path "${args[@]}" "$@"
        }
    
    ## no executable method was resolved, so try some built-ins:
    
    test $TOB_method = path && {
        test -z "$*" && echo $TOB_path_to_object/
        # list the path to any arguments found in the object:
        for arg in $*; do
            test -e $arg ||
                error -x 121 "$arg not found"
            echo $TOB_path_to_object/$arg
        done
        exit
        }
    
    test "$TOB_method" = "type" &&
        echo $TOB_type &&
            exit
    
    ## no method was found, so check for _default method...
    
    for path in ${mpaths[@]}; do
        ## ASSERT: class exists
        test -e $path/_default && {
            test -x $path/_default && {
                debug "tob: exec $path/_default $TOB_object $TOB_method $*"
                exec $path/_default $TOB_method "$@"
                }
            ## ASSERT: _default exists but is not executable
            ## maybe it can contain a recipe to be executed?
            error -x 122 "non-executable _default method found"
            }
    done
    
    error -x 123 "no method $TOB_method found"
    } # end main()

main "$@"

exit
NAME
    tob -- parse and resolve object.method, invoke method in object directory

SYNOPSIS
    tob [OPTIONS] object.method [METHOD_OPTIONS] [ARGUMENTS]
    tob -m method [-a arg]... object...

DESCRIPTION
    Thinobject strives to achieve object oriented programming and data
    management directly on the filesystem, in a language-independent way.
    Methods are executable programs, written in any language.  Thinobject
    uses a symlink, .^ or ^, to a class directory (or handler).  Methods
    and attributes are searched for along the chain of class links.

EXIT VALUE
    Exit value should be 0 if no error occurred, but should have a value
    from 101 to 123 if there was an error.  The numbers are assigned
    sequentially in the tob script, and for now that's the only documentation
    for what specific values mean.

OPTIONS
    -d
    --debug
    turn on debug output

    -v
    --verbose
    turn on verbose output

    -m M
    --method M
    apply method M to the following list of objects    

    -a ARGS...
    --arg ARGS...
    provide arguments; useful in conjunction with the --method option

    -h
    --help
    show this help screen (manpage)

    -q
    --quiet
    suppress output to stderr on errors
    
OBJECT CREATION
    Use tob-new to create objects.

BUILT-IN METHODS
    path
        output the object directory path

    type
        output the class hierarchy

PROPERTIES
    The thinobject system uses ordinary files and directories in the
    filesystem, so the content of an object is arbitrary.  It may be
    convenient/helpful to think of the contents of an object as its
    ``properties'', if only to distinguish them from otherwise ordinary
    files (which they really are).

    Special meaning is applied to certain files, as follows:

    ^
    .^
    symlink to the parent class

    ^foo
    .^foo
    symlink to a mixin class


SEARCH PATHS
    tob prepares a search path for methods and one for attributes.
    These differ mainly in that methods are not resolved in the object,
    while attributes may be.

    Mixin classes are searched before the parent class, in lexical 
    order.  Common ancestor classes are searched last. 

EXPORTED VARIABLES
    TOB_object -- the object name as passed to the thinob enabler

    TOB_method -- the invoked method

    TOB_type -- the nominal class name

    TOB_class_path -- the class directory or handler path

    TOB_object_path -- the fully resolved object name

    TOB_search_paths -- search paths for object attributes

    TOB_method_paths -- search paths for object methods

    TOB_caller_path

    TOB_caller_path_to_object

    TOB_path_to_object

EXPORTED FUNCTIONS
    TOB_resolve_method_path
    TOB_get_attr

   output format is: $TOB_object.$TOB_method: ARGUMENTS...

SEE ALSO
    tob-new --help
    tob-del --help
    Ideally, each thinobject class will provide a help method, and a
    --help option to each of its methods.

BUGS
    This is an experimental system.

    Not sure the --quiet option is working quite right...

    Should document all exit values.

AUTHOR
    Ken.Irving@alaska.edu (c) 2007-2010
