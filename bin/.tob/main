main () {
    test -n "$TOBLIB" || error -x 102 "TOBLIB is not set"
    ## process argument list options:
    declare path= object= method=
    declare -a args=() types=() mpaths=() apaths=() attr=()
    declare -i super=0
    qry=$1 && shift
    while test "${qry:0:1}" = -; do # handle option...
        case $qry in
            -q | --quiet)       QUIET=1;        opt="$opt -q" ;;
            -v | --verbose)     VERBOSE=1;      opt="$opt -v" ;;
            -d | --debug)       DEBUG=1;        opt="$opt -d" ;;
            -h | --help)        exec awk '/^NAME$/,0' $0 ;;
            -a | --arg)         args+=($1) && shift ;;
            -m | --method)      method=$1 && shift
                test $method || error -x 101 "no method argument" ;;
            *) error -x 102 "unsupported option $qry" ;;
        esac
        qry=$1 && shift # try again...
    done
    
    test -n "$qry" || error -x 103 "no object specified"
    
    test -n "$method" && method_option $qry "$@"  # ... will not return!

    test ${qry/.//} = $qry && # no dot found, so exec as, i.e., self.method
        exec $0 ..$qry "$@"

    declare -x TOB_caller_path=$PWD

    # set: path, object, method, super

    resolve_query $qry # will set: path, object, method, super
    return_status=$?

    test -n "$DEBUG" && printf "DEBUG: %15s = %s\n" \
        object $object      method $method \
        super $super        type "${type[*]}" \
        TOB_caller_path     $TOB_caller_path \
        args1 "${args[*]}"  args2 "$*"
   
exit 118
    
    ## a couple of assertion checks, probably redundant:
    test -n "$type" ||
        error -x 118 "failed to resolve $object type"
    test -n "$TOB_path_to_object" ||
        error -x 119 "failed to resolve path to $object"
    
    test -n "$DEBUG" && { # all of these should now be set:
        warn "DEBUG: TOB_path_to_object=$TOB_path_to_object"
        warn "DEBUG: calling: resolve_search_paths . $type"
        }
    
    # resolve_paths() builds arrays: types and paths, recursing on mixins
    # - first of 2 args is the object, not class, may include mixins
    # - types array is 1:1 with path after skipping paths[0]
    if test -n "${attr[*]}"; then
        unset attr[0]   # this is type, any other entries are envars
        resolve_search_paths $type
        object=$TOB_path_to_object
    else
      # warn "CASE 2"
        unset attr[0]   # this is type, any other entries are envars
        resolve_search_paths . $type
    fi

    test -n "$DEBUG" && { # all of these should now be set:
        warn "DEBUG: TYPES=<$types>,    ${#types[*]} entries"
        warn "DEBUG: MPATH=<$mpaths>, ${#mpaths[*]} entries"
        warn "DEBUG: APATH=<$apaths>, ${#apaths[*]} entries"
        }
    
    test -n "$types" || {
        test "${#apaths[@]}" -gt 1 &&
            error -x 120 "prototype but no type resolved for $object"
        error -x 121 "no type or prototype resolved for $object"
        }

    test -n "$DEBUG" && { # all of these should now be set:
        warn "DEBUG: top types=<$types>,    ${#types[*]} entries"
        warn "DEBUG: top mpaths=<$mpaths>, ${#mpaths[*]} entries"
        warn "DEBUG: top apaths=<$apaths>, ${#apaths[*]} entries"
        }
    
    test "$types" || {
        test "${#apaths[@]}" -gt 1 &&
            error -x 120 "prototype but no type resolved for $object"
        error -x 121 "no type or prototype resolved for $object"
        }

    # arrays may have duplicate entries, so leave only the last such entry
    cull_duplicate_paths
    
    ## export thinobject variables
    export TOB_object=$object
    export TOB_method=$method
    export TOB_type=$type
    export TOB_class_path
    export TOB_caller_path
    export TOB_caller_path_to_object=$TOB_path_to_object
    
    ## export thinobject utility functions and associated variables:
    export -f TOB_resolve_method_path
    export TOB_method_path
    export -f TOB_get_attr
    
    # create pseudo-arrays for export, with colon as delimiter:
    save_IFS="$IFS"
    IFS=:
    export TOB_search_paths="${apaths[*]}"
    export TOB_method_paths="${mpaths[*]}"
    export TOB_type="${types[*]}"
    IFS="$save_IFS"
    
    test -n "$DEBUG" && {
        warn "DEBUG: TOB_search_paths=$TOB_search_paths"
        warn "DEBUG: TOB_method_paths=$TOB_method_paths"
        warn "DEBUG: TOB_type=$TOB_type"
        }
    
    for envar in "${attr[@]}"; do
        tag=${envar%%=*}
        test $tag = $envar && continue
        val=${envar#*=}
        export $tag=$val
    done
    
    resolve_method_path $TOB_method &&
        exec $TOB_method_path "${args[@]}" "$@"
    
    ## no executable method was resolved, so try some built-ins:
    
    test $TOB_method = path && {
        test -z "$*" && echo $TOB_path_to_object/
        for arg in $*; do
            test -e $arg ||
                error -x 121 "$arg not found"
            echo $TOB_path_to_object/$arg
        done
        exit
        }
    
    test "$TOB_method" = "type" &&
        echo $TOB_type &&
            exit
    
    ## no method was found, so check for _default method...
    
    for path in ${mpaths[@]}; do
        ## ASSERT: class exists
        test -e $path/_default && {
            test -x $path/_default && {
              # warn "DEBUG tob: exec $path/_default $TOB_object $TOB_method $*"
                exec $path/_default $TOB_method "$@"
                }
            ## ASSERT: _default exists but is not executable
            ## maybe it can contain a recipe to be executed?
            error -x 122 "non-executable _default method found"
            }
    done
    
    error -x 123 "no method $TOB_method found"
    } # end main()
