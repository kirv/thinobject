main () {
    test -n "$TOBLIB" || error -x 102 "TOBLIB is not set"
    declare path= object= method= 
    declare -a types=() mpaths=() apaths=() envars=()
    test -n "$DEBUG" || alias debug=\#

    test -n "$1" || error -x 103 "no object specified"
    
    TOB_query=$1 && shift # expecting OBJECT.METHOD

    test ${TOB_query/./} = $TOB_query &&  # no object, so assume self object
        TOB_query=..$TOB_query
    
    declare -x TOB_caller_path=$PWD

    declare -a TOB_query=${1//\//\/.}   # change all / to /. for splitting
    query=(${query//./ })               # split on dot into array
    test ${query:0:1} = / && path='' || path=.
    declare -i m=$((${#query[*]}-1)) o=0 # o->prospective object, m->method

    while test ! -n "$method"; do

        # set path, leave o pointing to next element
        resolve_path ||
            error -x 1 "failed to resolve path from query after $path"
    
        if test $o -eq $m; then
            resolve_anonymous_object || {
                test $? .eq 2 && 
                    error -x 2 "failed to cd into anonymous object at path $path"
                cd -  # restore original working dir
                }
    
        test -n "$method" || {
    
            # assert: o<m
        
            # we could look for shadow objects, but that should happen with apaths
        
            resolve_named_object
    
            }
        
        test -n "tried_default" &&
            error -x 3 "failed to resolve object.method from query"

        query+=(default)
        m+=1
        tried_default=1
    done 


    
    types=() mpaths=() apaths=() envars=()

    # resolve_search_paths() builds arrays: types and paths, recursing on mixins
    # - first of 2 args is the object, not class, may include mixins
    # - types array is 1:1 with path after skipping paths[0]
    if test -n "${attr[*]}"; then
        unset attr[0]   # this is type, any other entries are envars
        resolve_search_paths $type
        object=$TOB_path_to_object
    else
        unset attr[0]   # this is type, any other entries are envars
        resolve_search_paths . $type
    fi

    test -n "$types" || {
        test "${#apaths[@]}" -gt 1 &&
            error -x 120 "prototype but no type resolved for $object"
        error -x 121 "no type or prototype resolved for $object"
        }


    ## export thinobject variables
    export TOB_object=$object
    export TOB_method=$method
    export TOB_type=$type
    export TOB_class_path
    export TOB_caller_path
    export TOB_caller_path_to_object=$TOB_path_to_object
    
    ## export thinobject utility functions and associated variables:
    export -f TOB_resolve_method_path
    export TOB_method_path
    export -f TOB_get_attr
    
    # create pseudo-arrays for export, with colon as delimiter:
    save_IFS="$IFS"
    IFS=:
    export TOB_search_paths="${apaths[*]}"
    export TOB_method_paths="${mpaths[*]}"
    export TOB_type="${types[*]}"
    IFS="$save_IFS"
    
    for envar in "${attr[@]}"; do
        tag=${envar%%=*}
        test $tag = $envar && continue
        val=${envar#*=}
        export $tag=$val
    done
    
    resolve_method_path $TOB_method &&
        exec $TOB_method_path "${args[@]}" "$@"
    
    ## no executable method was resolved, so try some built-ins:
    
    test "$TOB_method" = "type" &&
        echo $TOB_type &&
            exit
    
    ## no method was found, so check for _default method...
    
    for path in ${mpaths[@]}; do
        ## ASSERT: class exists
        test -e $path/_default && {
            test -x $path/_default && {
                debug "tob: exec $path/_default $TOB_object $TOB_method $*"
                exec $path/_default $TOB_method "$@"
                }
            ## ASSERT: _default exists but is not executable
            ## maybe it can contain a recipe to be executed?
            error -x 122 "non-executable _default method found"
            }
    done
    
    error -x 123 "no method $TOB_method found"
    } # end main()
