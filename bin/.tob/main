main () {
    test -n "$TOBLIB" || error --exit 102 "TOBLIB is not set"
    ## process argument list options:
    unset method
    arg=$1 && shift
    while test "${arg:0:1}" = -; do # handle option...
        case $arg in
            -q | --quiet)       QUIET=1;        opt="$opt -q" ;;
            -v | --verbose)     VERBOSE=1;      opt="$opt -v" ;;
            -d | --debug)       DEBUG=1;        opt="$opt -d" ;;
            -h | --help)        exec awk '/^NAME$/,0' $0 ;;
            -a | --arg)         args="$args $1" && shift ;;
            -m | --method)      method=$1 && shift
                test $method || error --exit 101 "no method argument" ;;
            *) error --exit 102 "unsupported option $arg" ;;
        esac
        arg=$1 && shift # try again...
    done
    
    test -z "$arg" && error --exit 103 "no object specified"
    
    test $method && { ## dispatch method from -m or --method option on objects:
        while [ $arg ]; do
            if [ ${arg/=} != $arg ]; then # tag=value form detected
                args="$args $arg"
            else
                test $VERBOSE &&
                    echo $0 $opt $arg.$method $args
                $0 $opt $ob.$method $args ||
                    error --exit 104 "failed in $arg.$method"
            fi
            arg=$1 && shift
        done
        exit
        }
    
    test ${arg/.//} = $arg && # no dot found, so exec as ..method in 'self' object
        exec $0 ..$arg "$@"
    
    ## parse the method and object from the object.method specification:
    TOB_method=${arg##*.}
    TOB_object=${arg%.*}
    
    ## count and remove 'super' modifier(s) if at end of object:
    declare -i super=0
    while test "${TOB_object: -6}" = ".super"; do
        TOB_object=${TOB_object%.super}
        super+=1
    done

    test -n "$TOB_object" ||
        error --exit 105 "no object parsed from $arg with method $TOB_method"
    
    test -n "$TOB_method" ||
        error --exit 106 "no method parsed from $arg, object $TOB_object"
    
    ## resolve_object() may change directories, so store caller's location:
    TOB_caller_path=$PWD

    test -n "$DEBUG" && { # all of these should now be set:
        warn DEBUG: TOB_object=$TOB_object
        warn DEBUG: TOB_method=$TOB_method
        warn DEBUG: super count: $super
        warn DEBUG: TOB_caller_path=$TOB_caller_path
        warn DEBUG: "args1='$args' args2='$*'"
        }
    
    # resolve_object() should set TOB_type, TOB_path_to_object
    resolve_object $TOB_object
    return_status=$?
    case $return_status in
    1)  error --exit 111 failed to cd to $TOB_object at $TOB_path_to_object ;;
    2)  error --exit 112 $TOB_object at $TOB_path_to_object is $TOB_type ;;
    3)  error --exit 113 broken symlink: $TOB_object at $TOB_path_to_object ;;
    4)  error --exit 114 no $TOB_object type at $TOB_path_to_object ;;
    6)  test -z "$TOBLIB_NOT_OBJECT" ||
            error --exit 116 failed to resolve $TOB_object
        # ok to try to resolve tob library class as object
        # first dot-delimited element must exist as a directory
        prefix=${TOB_object%%.*}
        for toblib in $TOBLIB; do
            test -d $toblib/$prefix/ || continue
            exec $0 $toblib/$TOB_object.$TOB_method 
            # to fix: the above exec call is missing args...
        done
        error --exit 117 failed to resolve $TOB_object
        ;;
    esac

    ## a couple of assertion checks, probably redundant:
    test -n "$TOB_type" ||
        error --exit 118 failed to resolve $TOB_object type
    test -n "$TOB_path_to_object" ||
        error --exit 119 failed to resolve path to $TOB_object
    
    test -n "$DEBUG" && { # all of these should now be set:
        warn DEBUG: TOB_type=$TOB_type
        warn DEBUG: TOB_path_to_object=$TOB_path_to_object
        warn DEBUG: calling: resolve_search_paths . $TOB_type
        }
    
    # resolve_paths() builds arrays: types and paths, recursing on mixins
    # - first of 2 args is the object, not class, may include mixins
    # - types array is 1:1 with path after skipping paths[0]
    declare -a types mpaths apaths
    resolve_search_paths . $TOB_type

    test -n "$DEBUG" && { # all of these should now be set:
        warn DEBUG: top types="<$types>",    ${#types[*]} entries
        warn DEBUG: top mpaths="<$mpaths>", ${#mpaths[*]} entries
        warn DEBUG: top apaths="<$apaths>", ${#apaths[*]} entries
        }
    
    test "$types" || {
        test "${#apaths[@]}" -gt 1 &&
            error --exit 120 prototype but no type resolved for $TOB_object
        error --exit 121 no type or prototype resolved for $TOB_object
        }

    # arrays may have duplicate entries, so leave only the last such entry
    cull_duplicate_paths
    
    ## export thinobject variables
    export TOB_object
    export TOB_method
    export TOB_type
    export TOB_class_path
    export TOB_caller_path
    export TOB_caller_path_to_object=$TOB_path_to_object
    
    ## export thinobject utility functions
    export -f TOB_resolve_method_path
    export -f TOB_get_attr
    
    # create pseudo-arrays for export, with colon as delimiter:
    save_IFS="$IFS"
    IFS=:
    export TOB_search_paths="${apaths[*]}"
    export TOB_method_paths="${mpaths[*]}"
    export TOB_type="${types[*]}"
    IFS="$save_IFS"
    
    test -n "$DEBUG" && {
        warn DEBUG: TOB_search_paths=$TOB_search_paths
        warn DEBUG: TOB_method_paths=$TOB_method_paths
        warn DEBUG: TOB_type=$TOB_type
        }
    
    resolve_method_path $TOB_method &&
        exec $TOB_method_path $args "$@"
    
    ## no executable method was resolved, so try some built-ins:
    
    test $TOB_method = path && {
        test -z "$*" && echo $TOB_path_to_object/
        for arg in $*; do
            test -e $arg ||
                error --exit 121 $arg not found
            echo $TOB_path_to_object/$arg
        done
        exit
        }
    
    test "$TOB_method" = "type" &&
        echo $TOB_type &&
            exit
    
    ## no method was found, so check for _default method...
    
    for path in ${mpaths[@]}; do
        ## ASSERT: class exists
        test -e $path/_default && {
            test -x $path/_default && {
              # warn DEBUG tob: exec $path/_default $TOB_object $TOB_method $*
                exec $path/_default $TOB_method "$@"
                }
            ## ASSERT: _default exists but is not executable
            ## maybe it can contain a recipe to be executed?
            error --exit 122 'non-executable _default "method" found'
            }
    done
    
    error --exit 123 "no method $TOB_method found"
    } # end main()
