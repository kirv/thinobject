#!/bin/bash

TOB_DEFAULT_CLASS_FOR_DIRECTORY=/usr/local/lib/thinob/Filesystem/Directory

# require class handlers & methods to be under one of these paths:
libroots=( ~/lib/tob /usr/local/lib/tob /opt/lib/tob /usr/lib/tob /lib/tob )

# the following is for a particular host where /usr/local/ is a symlink...
libroots=( ${libroots[@]} /home/.usr-local/lib/tob )

manpage() { # print manpage at end of this script...
    exec /usr/bin/awk '/^NAME$/{ok=1}ok' $0
    }

bail () {
    test -z "$QUIET" && echo $* >&2
    exit 1
    }

TOB_error () {
    unset EXIT_VALUE
    while [ "${1:0:1}" == "-" ]; do # handle option ...
        opt=$1 && shift
        case $opt in
        --exit|-x) EXIT_VALUE=$1 && shift ;;
        -v) VERBOSE=1 ;;
        -V) unset VERBOSE ;;
        *)  echo "TOB_error(): unknown option: \"$opt\"" 1>&2
            echo "    SYNOPSIS: TOB_error [--exit|-x N] [-v|V] args ..." 1>&2
            ;;
        esac
    done
    echo -e $TOB_object.$TOB_method: $* 1>&2
    set | grep ^TOB_ 1>&2
    test "$EXIT_VALUE" && exit $EXIT_VALUE
    }   

resolve_object () {  # set classlink to '^', '.^', or ''; or return 1
    test -d $1 ||
        return 1 # not a directory
    test -L $1/.^ -a -d $1/.^/ &&
        classlink='.^'
    test -L $1/^ -a -d $1/^/ &&
        classlink='^'
    # just a directory, so return true but with classlink not set
    }

resolve_and_chdir_into_object () {
    # returns 0 and with last_classlink set if object, not set if directory
    # returns 1 on any error
    # returns 2 if target is a file
    local ob_spec="$1"
    TOB_path_to_object=. # assume relative path
    test ${ob_spec:0:1} == / &&
        TOB_path_to_object="" # no, it's an absolute path
    unset last_classlink # global variable, set from resolve_object() classlink
    for direntry in ${ob_spec//\//\/ }; do # split on, and leave, slashes
        unset prefix
        test ${ob_spec:0:1} == . && # special case: dir or ob begins with dot
            prefix=.
        for obentry in ${direntry//./ }; do # split on dots
            obentry=$prefix$obentry
            echo TRY TO RESOLVE $obentry
            if test ${obentry: -1:1} == /; then  # ... obentry is a directory
                TOB_path_to_object=$TOB_path_to_object/${obentry%/} # ... omit slash
                cd $obentry ||
                    return 1
                unset last_classlink
            elif resolve_object $obentry; then # ... case: foo
                TOB_path_to_object=$TOB_path_to_object/$obentry
                cd $obentry ||
                    return 1
                last_classlink=$classlink
            elif resolve_object .$obentry; then # ... case: .foo
                TOB_path_to_object=$TOB_path_to_object/.$obentry
                cd .$obentry ||
                    return 1
                last_classlink=$classlink
            elif test -L $obentry; then # ... case: foo -> /some/path
                local save_path=$TOB_path_to_object
                resolve_and_chdir_into_object $(/bin/readlink -f $obentry)
                test ${TOB_path_to_object:0:1} == / ||
                    TOB_path_to_object=$save_path/$TOB_path_to_object
            elif test -L .$obentry; then # ... case: .foo -> /some/path
                local save_path=$TOB_path_to_object
                resolve_and_chdir_into_object $(/bin/readlink -f .$obentry)
                test ${TOB_path_to_object:0:1} == / ||
                    TOB_path_to_object=$save_path/$TOB_path_to_object
            elif test -d $obentry; then
                TOB_path_to_object=$TOB_path_to_object/$obentry
                unset last_classlink
                cd $obentry ||
                    return 1
            elif test -d .$obentry; then
                TOB_path_to_object=$TOB_path_to_object/.$obentry
                unset last_classlink
                cd .$obentry ||
                    return 1
            elif test -f $obentry; then
                unset last_classlink
                TOB_file_object=$obentry
                return 2
            elif test -f .$obentry; then
                unset last_classlink
                TOB_file_object=$obentry
                return 2
            elif test $obentry == super; then
                # should we check that super comes only at the end?
                super=$(($super + 1))
            else
                # combine this obentry with next one, separated by a dot
                prefix=${obentry}.
                unset last_classlink
                continue
            fi
            unset prefix
        done
    done
    }

resolve_attribute_search_path () {
    # search starts with the object path, followed by its class path:
    attr_paths=(. $TOB_class_path)
    # declare index to last and next entries in path array
    local last=1
    local next=2
    while test -d ${attr_paths[$last]}/; do
        if test -L ${attr_paths[$last]}/^; then
            attr_paths[$next]=${attr_paths[$last]}/^
        elif test -L ${attr_paths[$last]}/.^; then
            attr_paths[$next]=${attr_paths[$last]}/.^
        else
            break
        fi
        last=$next
        next=$(($next + 1))
    done
    }

check_and_parse_class () { # true if class begins with allowed root
    local class=$1
    test -L $class &&
         class=$(/bin/readlink -f $class)
    for path in ${libroots[@]}; do
        test ${class#$path/} == $class || {
            classname=${class#$path/}  # note: classname var set as side effect
            return
            }
    done
    return 1
    }

resolve_method_search_path () {
    # method search starts with object class, 2nd entry in attr_paths array:
    local attr_index=1
    test -n "${attr_paths[$attr_index]}" ||
        bail attr_paths array not initialized
    local index=0
    while test -n "${attr_paths[$attr_index]}"; do
        check_and_parse_class ${attr_paths[$attr_index]} && {
            search_paths[$index]=${attr_paths[$attr_index]}
            class_names[$index]=$classname
            index=$(($index + 1))
            attr_index=$(($attr_index + 1))
            continue
            }
        ## the class did not start with one of libroots list
        test $index == 0 || 
            bail non-method class cannot follow method class in search path
        attr_index=$(($attr_index + 1))
    done
    test -n "$search_paths" ||
        return 1
    }

## the next function is for internal use, the following on is for export:
resolve_method_path () {
    local method=$1
    # uses global super, i.e., count of how many times to skip matched method
    for searchpath in ${search_paths[@]}; do
        test -x $searchpath/$method && {
            test $super == 0 && {
                TOB_method_path=$searchpath/$method
                return
                }
            super=$(($super - 1))
            }
    done
    return 1
    }

TOB_resolve_method_path () {
    local method=$1
    local super=0
    while test "${method:0:6}" == "super."; do
        method=${method:6}
        super=$(($super + 1))
    done
    for searchpath in ${TOB_method_search_paths//:/ }; do
        test -x $searchpath/$method && {
            test $super == 0 && {
                TOB_method_path=$searchpath/$method
                return
                }
            super=$(($super - 1))
            }
    done
    return 1
    }

## process argument list options:
arg=$1 && shift
unset method
while [ -n "$arg" -a "${arg:0:1}" == "-" ]; do # handle option ...

    if [ "$arg" == "-d" -o "$arg" == "--debug" ]; then
        DEBUG=1
        opt="$opt -d"

    elif [ "$arg" == "-v" -o "$arg" == "--verbose" ]; then
        VERBOSE=1
        opt="$opt -v"

    elif [ "$arg" == "-m" -o "$arg" == "--method" ]; then
        method=$1 && shift
        test $method || bail "no method argument"

    elif [ "$arg" == "-a" -o "$arg" == "--arg" ]; then
        args="$args $1" && shift

    elif [ "$arg" == "-S" -o "$arg" == "--not-strict" ]; then
        NOT_STRICT=1
        opt="$opt -S"

    elif [ "$arg" == "-q" -o "$arg" == "--quiet" ]; then
        QUIET=1
        opt="$opt --quiet"

    elif [ "$arg" == "-h" -o "$arg" == "--help" ]; then
        manpage
        exit
    
    else
        bail "unsupported option $arg"
    fi
    arg=$1 && shift # try again...
done

test -z "$arg" && bail "no object specified"

test $method && { ## dispatch method from -m or --method option on objects:
    while [ $arg ]; do
        if [ ${arg/=} != $arg ]; then # tag=value form detected
            args="$args $arg"
        else
            test $VERBOSE &&
                echo $0 $opt $arg.$method $args
            $0 $opt $ob.$method $args ||
                bail "failed in $arg.$method"
        fi
        arg=$1 && shift
    done
    exit
    }

test ${arg/.//} == $arg && ## could/should provide a default method?
    bail no dot in object.method specifier $arg

## parse the method and object from the object.method specification:
TOB_method=${arg##*.}
TOB_object=${arg%.*}

test -n "$TOB_object" ||
    bail "no object parsed from $arg with method $TOB_method"

test -n "$TOB_method" ||
    bail "no method parsed from $arg, object $TOB_object"

## initialize method superizer:
super=0

## the next method will change directories, so store caller's location:
TOB_caller_path=$PWD

resolve_and_chdir_into_object $TOB_object
return_code=$?

if test $return_code == 1; then
    bail failed to resolve object: $TOB_object

elif test $return_code == 2; then
    TOB_class_path=$TOB_DEFAULT_CLASS_FOR_FILE
    echo pwd is $PWD
    echo query object was $TOB_object
    echo file object is $TOB_file_object
    bail $TOB_object resolved to a file ... how to handle it?

elif test -n "$last_classlink"; then
    echo object $TOB_object is a thinobject
    echo last_classlink is $last_classlink
    TOB_class_path=./$classlink
else
    echo object $TOB_object is a directory
    TOB_class_path=$TOB_DEFAULT_CLASS_FOR_DIRECTORY
fi

test -n "$DEBUG" && {
    echo DEBUG: TOB_object=$TOB_object
    echo DEBUG: TOB_method=$TOB_method
    echo DEBUG: TOB_path_to_object=$TOB_path_to_object
    echo DEBUG: TOB_caller_path=$TOB_caller_path
    }

test -n $TOB_class_path || 
    bail no object path resolved from $TOB_object

test -n "$DEBUG" && {
    echo DEBUG: TOB_path_to_object=$TOB_path_to_object
    echo DEBUG: TOB_class_path=$TOB_class_path
    }

test -n "$DEBUG" &&
    echo DEBUG: args1=\'$args\' args2=\'$*\'
    
declare -a attr_paths
resolve_attribute_search_path ||
    bail failure in resolve_attribute_search_path function

declare -a search_paths
declare -a class_names
resolve_method_search_path ||
    bail failed to resolve method search path

## export thinobject variables
export TOB_object
export TOB_method
export TOB_class_path
export TOB_caller_path
export TOB_path_to_object

## export thinobject utility functions
export -f TOB_error
export -f TOB_resolve_method_path

# create pseudo-arrays for export:
save_IFS="$IFS"
IFS=:
export TOB_attribute_search_paths="${attr_paths[*]}"
export TOB_method_search_paths="${search_paths[*]}"
export TOB_type="${class_names[*]}"
IFS="$save_IFS"

test -n "$DEBUG" && {
    echo DEBUG: TOB_attribute_search_paths=$TOB_attribute_search_paths
    echo DEBUG: TOB_method_search_paths=$TOB_method_search_paths
    echo DEBUG: TOB_type=$TOB_type
    }

resolve_method_path $TOB_method &&
    exec $TOB_method_path $args $@

## no executable method was resolved, so try some built-ins:

test $TOB_method == path && {
    test -z "$*" && echo $TOB_path_to_object
    for arg in $*; do
        echo $TOB_path_to_object/$arg
    done
    exit
    }

test "$TOB_method" == "type" &&
    echo $TOB_type &&
        exit

## no method was found, so check for _default method...

for path in ${search_paths[@]}; do
    ## ASSERT: class exists
    test -e $path/_default && {
        test -x $path/_default && {
          # echo DEBUG thinob: exec $path/_default $TOB_object $TOB_method $*
            exec $path/_default $TOB_method $*
            }
        ## ASSERT: _default is not executable
        ## maybe it can contain a recipe to be executed?
        bail 'non-executable _default "method" found'
        }
done

bail "no method $TOB_method found"

## manpage follows
NAME
    tob -- parse and resolve object.method, invoke method in object directory
SYNOPSIS
    tob [OPTIONS] object.method [METHOD_OPTIONS] [ARGUMENTS]
    tob -m method object...
DESCRIPTION
    Thinobject strives to achieve object oriented programming and data
    management directly on the filesystem, in a language-independent way.
    Methods are executable programs, written in any language.  Thinobject
    uses a symlink, .^ or ^, to a class directory (or handler).  Methods
    and attributes are searched for along the chain of class links.
RETURN VALUE
    0   ok, no error
    1   some error occurred
OPTIONS
    -d
    --debug
    turn on debug output

    -v
    --verbose
    turn on verbose output

    -m M
    --method M
    apply method M to the following list of objects    

    -a ARGS...
    --arg ARGS...
    provide arguments; useful in conjunction with the --method option

    -h
    --help
    show this help screen (manpage)

    -q
    --quiet
    suppress output to stderr on errors
    
OBJECT CREATION
    Use thinob-new or tob-new to create objects.

BUILT-IN METHODS
    path
    output the object directory path

    type
    output the class hierarchy

    foo [ARG]...
    if no method ``foo'' is found in the class hierarchy, search
    for a LIST property (@foo) or a DICTIONARY property (%foo) and
    treat this pseudo method as an ``accessor'' of that property.

PROPERTIES
    The thinobject system uses ordinary files and directories in the
    filesystem, so the contents of an object is arbitrary.  It may be
    convenient/helpful to think of the contents of an object as its
    ``properties'', if only to distinguish them from otherwise ordinary
    files (which they really are).

    Special meaning is applied to certain files, as follows:

    ^
    .^
    symlink to the parent class

    @
    @foo
    .@
    .@foo
    list property, a file containing a list of entries, one per line.
    @, the anonymous list property, may be scanned when any object method
    is invoked.

    %
    %foo
    .%
    .%foo
    dictionary property, file containing a list of tag=value entries,
    one pair per line.  %, the anonymous dictionary property, may be 
    scanned in automatically during method invocation, so can be used
    to store various object attributes.

    %@
    %@foo
    .%@
    .%@foo
    dictionary property implemented as a list, with keys listed all
    the first line, values on subsequent lines.  Blank lines and 
    comments lines are skipped.

    foo=bar
    attribute 'foo' is assigned the value 'bar'.

EXPORTED VARIABLES
    TOB_object -- the object name as passed to the thinob enabler

    TOB_class -- the nominal class name

    TOB_class_path -- the class directory or handler path

    TOB_object_path -- the fully resolved object name

    TOB_method -- the invoked method

    TOB_PATH -- search path for object through class hierarchy

EXPORTED FUNCTIONS
    TOB_error -- print message on STDERR
        SYNOPSIS: TOB_error [--exit|-x NUMBER] [-v|V] message ..."
        OPTIONS:
            --exit N  -- specify exit status number
            -x N      -- specify exit status number
            -v        -- be verbose; show thinobject state variables
            -V        -- don't be verbose
        output format is: $TOB_object.$TOB_method: ARGUMENTS...

SEE ALSO
    tob-new --help
    tob-del --help
    Ideally, each thinobject class will provide a help method, and a
    --help option to each of its methods.

BUGS
    This is an experimental system.

    Not sure the --quiet option is working quite right...

AUTHOR
    Ken Irving <fnkci@uaf.edu> (c) 2007-2009
END_OF_MANPAGE
