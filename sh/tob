#!/bin/bash

# tob -- thinobject 'enabler' program
# Copyright (C) 2010 Ken Irving
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

warn () {
    test -z "$QUIET" && printf "%s\n" "$*" >&2
    }

error () {
    exitvalue=1
    test -n "$1" -a $1 = --exit && shift && exitvalue=$1 && shift
    warn "$*"
    exit $exitvalue
    }

get_type () { # set TOB_type, but also cd into object or return 1 if unable
    unset TOB_type
    # TODO: check xattr tob.^ for type
    type="$(stat -L -c %F $1 2> /dev/null)"
    case "${type%% *}" in
        directory)
            TOB_type=Directory
            test -L $1/^ && TOB_type=$(readlink ^)
            test -L $1/.^ && TOB_type=$(readlink .^)
            cd $1 2> /dev/null || return 1
            return
            ;;
        regular)   TOB_type=File;;
        fifo)      TOB_type=NamedPipe;;
        socket)    TOB_type=Socket;;
        character) TOB_type=CharacterSpecial;;
        block)     TOB_type=BlockSpecial;;
    esac
    test -z "$TOB_type" && test -l $arg && TOB_type=SymLink
    return 1
    }

chdir_into_object () {
    # set TOB_type, return 0
    # returns 1 on any error
    # returns 2 if target is a file
    local ob_spec="$1"

    case ${ob_spec:0:1} in
        /)  TOB_path_to_object=""  # absolute path
        *)  TOB_path_to_object="." # relative path
    esac

    for direntry in ${ob_spec//\//\/ }; do # split on, and leave, slashes
        unset prefix
        test ${ob_spec:0:1} = . && { # special case: dir or ob begins with dot
            prefix=.
            test $ob_spec = . && # special case: current directory
                direntry=/
            }
        for obentry in ${direntry//./ }; do # split on dots
            obentry=$prefix$obentry
            if test ${obentry: -1:1} = /; then  # foo/ explicitly
                TOB_path_to_object=$TOB_path_to_object/${obentry%/}
                cd $obentry ||
                    error --exit 105 failed to cd to $TOB_path_to_object
                get_type $obentry
            elif get_type $obentry; then # foo/^
                TOB_path_to_object=$TOB_path_to_object/$obentry
                cd $obentry ||
                    error --exit 106 failed to cd to $TOB_path_to_object
            elif test -z "$NO_HIDDEN" && get_type .$obentry; then # .foo/^
                TOB_path_to_object=$TOB_path_to_object/.$obentry
                cd .$obentry ||
                    error --exit 107 failed to cd to $TOB_path_to_object
            elif test -z "$NO_HIDDEN" && test -L $obentry; then # foo->bar->.bar/^
                local save_path=$TOB_path_to_object
                chdir_into_object $(/bin/readlink -f $obentry)
                test ${TOB_path_to_object:0:1} = / ||
                    TOB_path_to_object=$save_path/$TOB_path_to_object
            elif test -z "$NO_HIDDEN" && test -L .$obentry; then # .foo->bar->.bar/^
                local save_path=$TOB_path_to_object
                chdir_into_object $(/bin/readlink -f .$obentry)
                test ${TOB_path_to_object:0:1} = / ||
                    TOB_path_to_object=$save_path/$TOB_path_to_object
            elif test -d $obentry; then  # foo/
                TOB_path_to_object=$TOB_path_to_object/$obentry
                cd $obentry ||
                    error --exit 108 failed to cd to $TOB_path_to_object
            elif test -z "$NO_HIDDEN" -a -d .$obentry; then # .foo/
                TOB_path_to_object=$TOB_path_to_object/.$obentry
                cd .$obentry ||
                    error --exit 109 failed to cd to $TOB_path_to_object
            elif test -f $obentry; then # foo
                TOB_file_object=$obentry
                return 2
            elif test -z "$NO_HIDDEN" -a -f .$obentry; then # .foo
                TOB_file_object=.$obentry
                return 2
            else
                # combine this obentry with next one, separated by a dot
                prefix=${obentry}.
                continue
            fi
            unset prefix
        done
    done
    test -z "$prefix" || return 1 # no prefix should remain...
    }

resolve_paths () {
    local path=$1 && shift
  warn "in resolve_paths()..."
    while test -d $path/; do
        paths+=($path)
  warn "    path is now <$path>"
        for mixin in $path/{,.}^?*; do # e.g., ^Cron or .^Web
            test -z "$TOB_NO_MIXINS" || break
            test -L $mixin || continue
            # TODO: check if mixin points to prototype object?
            for toblib in $TOBLIB; do
                test -d $toblib/$mixin/ || continue
                resolve_paths $toblib/$mixin
                break
            done
        done
        unset type
        # TODO: check for xattr tob.^ before symlink ^ or .^
        if test -n "$1"; then
            # do not check for classlink in first arg if two args were passed
            path=$1 && shift
  warn "    path is now <$path> just pulled from arglist"
            break
        elif test -L $path/^; then
            type=$(readlink $path/^)
        elif test -L $path/.^; then
            type=$(readlink $path/.^)
        else
            break
        fi
        # assert: nextclass points either to ^ or .^ under $path/
        # TODO: see if nextclass points to prototype object
        types+=($type)
        unset path
        for toblib in $TOBLIB; do
            test -d $toblib/$type/ || continue
            path=$toblib/$type
            break
        done
    done
    }

cull_duplicate_paths () {
    local path
    local unique_paths
    typeset -i p
    p=${#paths[@]} # start at end to check entries in reverse order
 warn "we have $p paths defined"
    while test $p -gt 0; do 
        p+=-1
 warn "now p=$p..."
        path=${paths[$p]}
 warn "and path[$p] is <$path>..."
        test "${unique_paths/$path/}" = "$unique_paths" || {
            # this path already visited
            unset paths[$p]
            unset types[$p-1]
            continue
            }
        unique_paths+=" $path"
    done
    }

## the next function is for internal use, the following one is for export:
resolve_method_path () {
    local method=$1
    # uses global super, i.e., count of how many times to skip matched method
    for path in ${method_paths[@]}; do
        test -x $path/$method && {
            test $super -gt 0 && super+=-1 && continue
            TOB_method_path=$path/$method
            return
            }
    done
    return 1
    }

TOB_resolve_method_path () {
    local method=$1
    local super=0
    while test "${method:0:6}" = "super."; do
        method=${method:6}
        super+=1
    done
    for path in ${TOB_method_paths//:/ }; do
        test -x $path/$method && {
            test $super -gt 0 && super+=-1 && continue
            TOB_method_path=$path/$method
            return
            }
    done
    return 1
    }

TOB_get_attr () {
    # set variable 'attr' to attribute value(s), or return false
    # if $arg matches a file, scalar attr is set to its contents
    # if file(s) matches $arg=value, array attr is set to value(s)
    local arg=$1 path file
    test -n "$arg" || return 1
    for path in ${TOB_search_paths//:/ }; do
        test -e "$path/$arg" && attr=$(<$path/$arg) && return
        file=($path/$arg=*)
        test "${file: -1}" = '*' && continue
        attr=(${file[@]#$path/$arg=}) && return
    done
    return 1
    }

main () {

    ## process argument list options:
    unset method
    arg=$1 && shift
    while test "${arg:0:1}" = -; do # handle option...
        case $arg in
            --method | -m)
                method=$1 && shift
                test $method || error --exit 111 "no method argument"
                ;;
        
            --arg | -a)
                args="$args $1" && shift
                ;;
        
            --no-hidden | -H)
                NO_HIDDEN=1
                opt="$opt -H"
                ;;
        
            --quiet | -q)
                QUIET=1
                opt="$opt --quiet"
                ;;
        
            --verbose | -v)
                VERBOSE=1
                opt="$opt -v"
                ;;
    
            --help | -h)
                exec awk '/^NAME$/,0' $0
                ;;
            
            --debug | -d)
                DEBUG=1
                opt="$opt -d"
                ;;
                
            *)
                error --exit 112 "unsupported option $arg"
                ;;
        esac
        arg=$1 && shift # try again...
    done
    
    test -z "$arg" && error --exit 113 "no object specified"
    
    test $method && { ## dispatch method from -m or --method option on objects:
        while [ $arg ]; do
            if [ ${arg/=} != $arg ]; then # tag=value form detected
                args="$args $arg"
            else
                test $VERBOSE &&
                    echo $0 $opt $arg.$method $args
                $0 $opt $ob.$method $args ||
                    error --exit 114 "failed in $arg.$method"
            fi
            arg=$1 && shift
        done
        exit
        }
    
    test ${arg/.//} = $arg && # no dot found, so exec as ..method in 'self' object
        exec $0 ..$arg "$@"
    
    ## parse the method and object from the object.method specification:
    TOB_method=${arg##*.}
    TOB_object=${arg%.*}
    
    ## count and remove 'super' modifier(s) if at end of object:
    super=0
    while test "${TOB_object: -6}" = ".super"; do
        TOB_object=${TOB_object%.super}
        super+=1
    done

    test -n "$TOB_object" ||
        error --exit 116 "no object parsed from $arg with method $TOB_method"
    
    test -n "$TOB_method" ||
        error --exit 117 "no method parsed from $arg, object $TOB_object"
    
    
    ## the next method will change directories, so store caller's location:
    TOB_caller_path=$PWD
    
    unset TOB_type
    chdir_into_object $TOB_object
    return_code=$?
    
    unset TOB_class_path
    if test $return_code = 1; then
        error --exit 118 failed to resolve object: $TOB_object
    
    elif test $return_code = 2; then
        TOB_type=File
        for toblib in $TOBLIB; do
            test -d $toblib/File || continue
            TOB_class_path=$toblib/File
            break
        done
        warn pwd is $PWD
        warn query object was $TOB_object
        warn file object is $TOB_file_object
        error --exit 119 $TOB_object resolved to a file ... how to handle it?
    
    elif test -n "$TOB_type"; then
        for toblib in $TOBLIB; do
            test -d $toblib/$TOB_type/ || continue
            TOB_class_path=$toblib/$TOB_type
            break
        done
    else
        error --exit 124 no object type was found -- should not happen
    fi

    test -n "$TOB_class_path" ||
        error --exit 125 type $TOB_type did not resolve to a class directory
    
    test -n "$DEBUG" && {
        warn DEBUG: TOB_object=$TOB_object
        warn DEBUG: TOB_method=$TOB_method
        warn DEBUG: TOB_type=$TOB_type
        warn DEBUG: TOB_path_to_object=$TOB_path_to_object
        warn DEBUG: TOB_caller_path=$TOB_caller_path
        }
    
    test -n $TOB_class_path || 
        error --exit 120 no class dir resolved for $TOB_object of type $TOB_type
    
    test -n "$DEBUG" && {
        warn DEBUG: TOB_path_to_object=$TOB_path_to_object
        warn DEBUG: TOB_class_path=$TOB_class_path
        }
    
    test -n "$DEBUG" &&
        warn DEBUG: args1=\'$args\' args2=\'$*\'
        

    # resolve_paths() builds arrays: types and paths, recursing on mixins
    # - calling it with 2 args, arg2 is the resolved class path
    # - types array is 1:1 with path after skipping paths[0]
    types=()
    paths=()
  warn "before resolve_paths(): type $TOB_type -> $TOB_class_path"
    resolve_paths . $TOB_class_path
  warn " after resolve_paths(): type $TOB_type -> $TOB_class_path"
    # paths array now contains the full search path set, may have duplicates
  warn " after resolve_paths(): types: ${types[@]}"
  warn " after resolve_paths(): paths: ${paths[@]}"
    
    cull_duplicate_paths
  warn " after cull_duplicate_paths(): type $TOB_type -> $TOB_class_path"
    # arrays: paths, method_paths, class_names are defined (may be sparse)
  warn " after cull_duplicate_paths(): types: ${types[@]}"
  warn " after cull_duplicate_paths(): paths: ${paths[@]}"
    
    ## export thinobject variables
    export TOB_object
    export TOB_method
    export TOB_type
    export TOB_class_path
    export TOB_caller_path
    export TOB_caller_path_to_object=$TOB_path_to_object
    
    ## export thinobject utility functions
    export -f TOB_resolve_method_path
    export -f TOB_get_attr
    
    # create pseudo-arrays for export:
    save_IFS="$IFS"
    IFS=:
    export TOB_search_paths="${paths[*]}"
    export TOB_method_paths="${method_paths[*]}"
    export TOB_type="${types[*]}"
    IFS="$save_IFS"
    
    test -n "$DEBUG" && {
        warn DEBUG: TOB_search_paths=$TOB_search_paths
        warn DEBUG: TOB_method_paths=$TOB_method_paths
        warn DEBUG: TOB_type=$TOB_type
        }
    
    resolve_method_path $TOB_method &&
        exec $TOB_method_path $args "$@"
    
    ## no executable method was resolved, so try some built-ins:
    
    test $TOB_method = path && {
        test -z "$*" && echo $TOB_path_to_object/
        for arg in $*; do
            test -e $arg ||
                error --exit 121 $arg not found
            echo $TOB_path_to_object/$arg
        done
        exit
        }
    
    test "$TOB_method" = "type" &&
        echo $TOB_type &&
            exit
    
    ## no method was found, so check for _default method...
    
    for path in ${method_paths[@]}; do
        ## ASSERT: class exists
        test -e $path/_default && {
            test -x $path/_default && {
              # warn DEBUG tob: exec $path/_default $TOB_object $TOB_method $*
                exec $path/_default $TOB_method "$@"
                }
            ## ASSERT: _default exists but is not executable
            ## maybe it can contain a recipe to be executed?
            error --exit 122 'non-executable _default "method" found'
            }
    done
    
    error --exit 123 "no method $TOB_method found"
    } # end main()

main "$@"

exit 47 # should not happen

## manpage follows
NAME
    tob -- parse and resolve object.method, invoke method in object directory

SYNOPSIS
    tob [OPTIONS] object.method [METHOD_OPTIONS] [ARGUMENTS]
    tob -m method [-a arg]... object...

DESCRIPTION
    Thinobject strives to achieve object oriented programming and data
    management directly on the filesystem, in a language-independent way.
    Methods are executable programs, written in any language.  Thinobject
    uses a symlink, .^ or ^, to a class directory (or handler).  Methods
    and attributes are searched for along the chain of class links.

EXIT VALUE
    Exit value should be 0 if no error occurred, but should have a value
    from 101 to 123 if there was an error.  The numbers are assigned
    sequentially in the tob script, and for now that's the only documentation
    for what specific values mean.

OPTIONS
    -d
    --debug
    turn on debug output

    -v
    --verbose
    turn on verbose output

    -m M
    --method M
    apply method M to the following list of objects    

    -a ARGS...
    --arg ARGS...
    provide arguments; useful in conjunction with the --method option

    -h
    --help
    show this help screen (manpage)

    -q
    --quiet
    suppress output to stderr on errors
    
OBJECT CREATION
    Use tob-new to create objects.

BUILT-IN METHODS
    path
        output the object directory path

    type
        output the class hierarchy

    foo [ARG]...
        if no method ``foo'' is found in the class hierarchy, search
        for a LIST property (@foo) or a DICTIONARY property (%foo)
        and treat this pseudo method as an ``accessor'' of that property.

PROPERTIES
    The thinobject system uses ordinary files and directories in the
    filesystem, so the contents of an object is arbitrary.  It may be
    convenient/helpful to think of the contents of an object as its
    ``properties'', if only to distinguish them from otherwise ordinary
    files (which they really are).

    Special meaning is applied to certain files, as follows:

    ^
    .^
    symlink to the parent class

    ^foo
    .^foo
    symlink to a mixin class


SEARCH PATHS
    tob prepares a search path for methods and one for attributes.
    These differ mainly in that methods are not resolved in the object,
    while attributes may be.

    Mixin classes are searched before the parent class, in lexical 
    order.  Common ancestor classes are searched last. 

EXPORTED VARIABLES
    TOB_object -- the object name as passed to the thinob enabler

    TOB_method -- the invoked method

    TOB_type -- the nominal class name

    TOB_class_path -- the class directory or handler path

    TOB_object_path -- the fully resolved object name

    TOB_search_paths -- search paths for object attributes

    TOB_method_paths -- search paths for object methods

    TOB_caller_path

    TOB_caller_path_to_object

    TOB_path_to_object

EXPORTED FUNCTIONS
    TOB_resolve_method_path
    TOB_get_attr

   output format is: $TOB_object.$TOB_method: ARGUMENTS...

SEE ALSO
    tob-new --help
    tob-del --help
    Ideally, each thinobject class will provide a help method, and a
    --help option to each of its methods.

BUGS
    This is an experimental system.

    Not sure the --quiet option is working quite right...

    Should document all exit values.

AUTHOR
    Ken.Irving@alaska.edu (c) 2007-2010
