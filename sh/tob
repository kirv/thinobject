#!/bin/bash

# tob -- thinobject 'enabler' program
# Copyright (C) 2010 Ken Irving
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

warn () {
    test -z "$QUIET" && printf "%s\n" "$*" >&2
    }

error () {
    exitvalue=1
    test -n "$1" -a $1 = --exit && shift && exitvalue=$1 && shift
    warn "$*"
    exit $exitvalue
    }

<<<<<<< HEAD
get_type () {
    #               set TOB_path_to_object from arg 1
    #               set TOB_type after analysis
    #               cd into dir object, return 0, or 1 if cd failed 
    #               return 2 for regular or special file
    #               return 3 for symbolic link that does not resolve
    #               return 4 if no type identified
    #
    TOB_path_to_object=$1
    unset TOB_type
    type="$(stat -L -c %F $TOB_path_to_object 2> /dev/null)"
    case "${type%% *}" in                   # first word from stat(1) filetype
        directory)
            TOB_type=Directory
            # TODO: check xattr tob.^ for type
            test -L $TOB_path_to_object/.^ && TOB_type=$(readlink $TOB_path_to_object/.^)
            test -L $TOB_path_to_object/^ && TOB_type=$(readlink $TOB_path_to_object/^)
            cd $TOB_path_to_object 2> /dev/null || return 1
            return
            ;;
        regular)   TOB_type=File;;
        socket)    TOB_type=Socket;;
        fifo)      TOB_type=NamedPipe;;
        block)     TOB_type=BlockSpecial;;
        character) TOB_type=CharacterSpecial;;
    esac
    test -n "$TOB_type" && return 2
    test -L $arg && TOB_type=SymLink && return 3
    return 4
    }

resolve_object () { 
    #               return values 0 to 4 are from get_type()
    #               get_type() sets TOB_type, TOB_path_to_object
    #               return 5 if $hidden > 0 and --no-hidden was given
    #               return 6 if unable to resolve anything
    #
    local obspec=$1
    local path=. # assume path is relative
    declare -i hidden=0
    test ${obspec:0:1} = / && path="" # no, path is absolute
    unset prefix
    for elem in ${obspec//./ }; do          # split into elements on dots
        test -n "$prefix" && elem=$prefix.$elem && unset prefix
        if test ${elem: -1:1} = /; then     # element is explicitly a directory
            path+=/${elem%/}
        elif test -d $path/$elem; then      # dot-terminated directory
            path+=/$elem
        elif test -d $path/${elem%/*}/.${elem##*/}; then # hidden directory
            path="$path/${elem%/*}/.${elem##*/}"
            hidden+=1
        elif test -L $path/$elem; then      # hidden dir behind symlink?
            target=$(readlink -f $path/$elem)
            leaf=${target##*/}
            target=${target%/*}
            if test -d $target/.$leaf; then
                path=$target/.$leaf
                hidden+=1
=======
check_classroot () {
    # return true if class begins with allowed root
    # return false if class does not exist or does not begin at TOB_LIBRARY
    # variable classname is set on return if ^ or .^ is found
    local class=$(/bin/readlink -fe $1) ||
        error --exit 101 check failed for class $1 symlink
    for path in ${library[@]}; do
        test ${class#$path/} = $class || {
            classname=${class#$path/}
            return 0
            }
    done
    error --exit 102 bad TOB_LIBRARY check or bad class in $1
    return 1
    }

resolve_object () {  # set classlink to '^', '.^', or ''; or return 1
    test -d $1 ||
        return 1 # not a directory
    unset classlink 
    if test -L $1/.^; then
        classlink='.^'
    elif test -L $1/^; then
        classlink='^'
    fi
    test -n "$classlink" && {
        test -d $1/$classlink/ ||
            error --exit 103 classlink $1/$classlink/ does not exist
        test -z "$NOT_STRICT" && {
            check_classroot $1/$classlink ||
                error --exit 104 classlink $1/$classlink/ is not under TOB_LIBRARY
            }
        }
    return 0
    }

resolve_and_chdir_into_object () {
    # returns 0 and with last_classlink set if object, not set if directory
    # returns 1 on any error
    # returns 2 if target is a file
    local ob_spec="$1"
  # warn "TRY TO RESOLVE $ob_spec"
    TOB_path_to_object=. # assume relative path
    test ${ob_spec:0:1} = / &&
        TOB_path_to_object="" # no, it's an absolute path
    unset last_classlink # global variable, set from resolve_object() classlink
  # warn ob_spec: $ob_spec
    for direntry in ${ob_spec//\//\/ }; do # split on, and leave, slashes
      # warn direntry: $direntry
        unset prefix
        test ${ob_spec:0:1} = . && { # special case: dir or ob begins with dot
            test $direntry != ..super &&
                prefix=.
            test $ob_spec = . && # special case: current directory
                direntry=/
            }
        for obentry in ${direntry//./ }; do # split on dots
          # warn obentry: $obentry
            obentry=$prefix$obentry
          # warn obentry: $obentry
            if test ${obentry: -1:1} = /; then  # foo/ explicitly
              # warn foo/ explicitly
                TOB_path_to_object=$TOB_path_to_object/${obentry%/}
                cd $obentry ||
                    error --exit 105 failed to cd to $TOB_path_to_object
                resolve_object $obentry
                last_classlink=$classlink
            elif resolve_object $obentry; then # foo/^
              # warn foo/^
                TOB_path_to_object=$TOB_path_to_object/$obentry
              # warn MORE $TOB_path_to_object $classlink
                cd $obentry ||
                    error --exit 106 failed to cd to $TOB_path_to_object
                last_classlink=$classlink
            elif test -z "$NO_HIDDEN" && resolve_object .$obentry; then # .foo/^
              # warn .foo/^
                TOB_path_to_object=$TOB_path_to_object/.$obentry
                cd .$obentry ||
                    error --exit 107 failed to cd to $TOB_path_to_object
                last_classlink=$classlink
            elif test -z "$NO_HIDDEN" && test -L $obentry; then # foo->bar->.bar/^
              # warn 'foo -> bar -> .bar/^'
                local save_path=$TOB_path_to_object
                resolve_and_chdir_into_object $(/bin/readlink -f $obentry)
                test ${TOB_path_to_object:0:1} = / ||
                    TOB_path_to_object=$save_path/$TOB_path_to_object
            elif test -z "$NO_HIDDEN" && test -L .$obentry; then # .foo->bar->.bar/^
              # warn '.foo -> bar -> .bar/^'
                local save_path=$TOB_path_to_object
                resolve_and_chdir_into_object $(/bin/readlink -f .$obentry)
                test ${TOB_path_to_object:0:1} = / ||
                    TOB_path_to_object=$save_path/$TOB_path_to_object
            elif test -d $obentry; then  # foo/
              # warn foo/
                TOB_path_to_object=$TOB_path_to_object/$obentry
                unset last_classlink
                cd $obentry ||
                    error --exit 108 failed to cd to $TOB_path_to_object
            elif test -z "$NO_HIDDEN" -a -d .$obentry; then # .foo/
              # warn .foo/
                TOB_path_to_object=$TOB_path_to_object/.$obentry
                unset last_classlink
                cd .$obentry ||
                    error --exit 109 failed to cd to $TOB_path_to_object
            elif test -f $obentry; then # foo
              # warn foo
                unset last_classlink
                TOB_file_object=$obentry
                return 2
            elif test -z "$NO_HIDDEN" -a -f .$obentry; then # .foo
              # warn .foo
                unset last_classlink
                TOB_file_object=.$obentry
                return 2
            elif test $obentry = super; then # method resolution operator
              # warn super
                # should we check that super comes only at the end?
                super=$(($super+1))
          # elif test $obentry = .super; then # method resolution operator
          #     warn .super
          #     super=$(($super+1))
>>>>>>> 739b5b56
            else
                prefix=$elem
            fi
        elif test -L $path/.$elem; then     # hidden dir behind hidden symlink?
            target=$(readlink -f $path/.$elem)
            leaf=${target##*/}
            target=${target%/*}
            if test -d $target/.$leaf; then
                path=$target/.$leaf
                hidden+=1
            else
                prefix=$elem
            fi
        else
            prefix=$elem
        fi
    done
    test $hidden -gt 0 && test -n "$NO_HIDDEN" && return 5
    test -z "$prefix" && {  # a directory object was resolved
        get_type $path
        return
        }
    # try to resolve $path.$prefix as a regular or special file object...
    test -e $path/$prefix && {              # regular or special file
        get_type $path/$prefix
        return
        }
    test -n "$NO_HIDDEN" && return 5        # anything left must be hidden...
    test -e $path/.$prefix && {             # hidden regular or special file
        get_type $path/.$prefix
        return
        }
    test -L $path/$prefix && {              # hidden ob behind symlink?
        target=$(readlink -f $path/$prefix)
        leaf=${target##*/}
        target=${target%/*}
        test -e $target/.$leaf && {
            get_type $target/.$leaf
            return
            }
        }
    test -L $path/.$prefix && {             # hidden ob behind dot-symlink?
        target=$(readlink -f $path/.$prefix)
        leaf=${target##*/}
        target=${target%/*}
        test -e $target/.$leaf && {
            get_type $target/.$leaf
            return
            }
        }
    return 6                                # no object was resolved
    }

resolve_paths () { # process type or prototype object into types, apaths, mpaths
    local type=$1 && shift
    local path
    while test -n $type; do
        # a 'type' should not resolve as a directory, but only under TOBLIB
        # a 'prototype' resolves as a directory, but is used only for attributes
        if test -d $type; then
            path=$type
            apaths+=($path)
        else
            unset path
            for toblib in $TOBLIB; do
                test -d $toblib/$type/ || continue
                path=$toblib/$type
                break
            done
            test -n "$path" || return 1
            types+=($type)
            apaths+=($path)
            mpaths+=($path)
        fi

        for mixin in $path/{,.}^?*; do # e.g., ^Cron or .^Web or ^settings
            test -z "$TOB_NO_MIXINS" || break
            test -L $mixin || continue # has to be a symlink

            if test -d $mixin; then # prototype object
                mixin=$(readlink $mixin)
                if test ${mixin:0:1} = /; then # absolute path
                    resolve_paths $mixin
                else
                    resolve_paths $path/$mixin
                fi
            else # does not resolve, so assume it's a type
                resolve_paths $(readlink $mixin)
            fi
        done

        # if 2 args were passed, the 2nd is the already-known type of the first,
        # so do not look for class links in the 1st, but skip ahead to the 2nd...
        test -n "$1" && type=$1 && shift && continue

        # type has already been resolved to path, so look there for ^ or .^

        if test -L $path/^; then
            type=$(readlink $path/^)
        elif test -L $path/.^; then
            type=$(readlink $path/.^)
        else
            return 0
        fi
    done
    }

<<<<<<< HEAD
cull_duplicate_paths () {
    local entry
    local unique
    declare -i i
    # arrays types and mpaths are 1:1, so scan types, discard from both
    for (( i=${#types[@]}; i>=0; i-- )); do
        entry=${types[$i]}
        test "${unique/$entry/}" = "$unique" || {
            # this entry already scanned
            unset types[$i]
            unset mpaths[$i]
            continue
            }
        unique+=" $entry"
    done
    unset unique
    # apaths array can include duplicates, so scan & discard, leaving last
    for (( i=${#apaths[@]}; i>=0; i-- )); do
        entry=${apaths[$i]}
        test "${unique/$entry/}" = "$unique" || {
            # this entry already scanned
            unset apaths[$i]
            continue
            }
        unique+=" $entry"
=======
check_paths () {
    local all_paths
    method_paths=()
    class_names=()
    p=${#paths[@]} # start at end to check entries in reverse order
    while test $p -gt 0; do 
        p=$(($p-1))
        local path=${paths[$p]}
        fullpath=$(/bin/readlink -fe $path) ||
            error --exit 110 class path $path does not resolve
        test "${all_paths/$fullpath/}" = "$all_paths" || {
            # this path already visited
            unset paths[$p]
            continue
            }
        all_paths+=" $fullpath"
        full_paths[$p]=$fullpath
        for libroot in ${library[@]}; do
            test ${fullpath#$libroot/} = $fullpath || {
                # path is under one of the library roots, so is a 'class'
                method_paths[$p]=${paths[$p]}
                class_names[$p]=${fullpath#$libroot/}
                }
        done
>>>>>>> 739b5b56
    done
    }

## the next function is for internal use, the following one is for export:
resolve_method_path () {
    local method=$1
    # uses global super, i.e., count of how many times to skip matched method
    for path in ${mpaths[@]}; do
        test -x $path/$method && {
<<<<<<< HEAD
            test $super -gt 0 && super+=-1 && continue
            TOB_method_path=$path/$method
            return
=======
            test $super = 0 && {
                TOB_method_path=$path/$method
                return
                }
            super=$(($super - 1))
>>>>>>> 739b5b56
            }
    done
    return 1
    }

TOB_resolve_method_path () {
    local method=$1
    local super=0
    while test "${method:0:6}" = "super."; do
        method=${method:6}
        super+=1
    done
    for path in ${TOB_method_paths//:/ }; do
        test -x $path/$method && {
<<<<<<< HEAD
            test $super -gt 0 && super+=-1 && continue
            TOB_method_path=$path/$method
            return
=======
            test $super = 0 && {
                TOB_method_path=$path/$method
                return
                }
            super=$(($super - 1))
>>>>>>> 739b5b56
            }
    done
    return 1
    }

TOB_get_attr () {
    # set variable 'attr' to attribute value(s), or return false
    # if $arg matches a file, scalar attr is set to its contents
    # if file(s) matches $arg=value, array attr is set to value(s)
    local arg=$1 path file
    test -n "$arg" || return 1
    for path in ${TOB_search_paths//:/ }; do
        test -e "$path/$arg" && attr=$(<$path/$arg) && return
        file=($path/$arg=*)
        test "${file: -1}" = '*' && continue
        attr=(${file[@]#$path/$arg=}) && return
    done
    return 1
    }

main () {

    ## process argument list options:
    unset method
    arg=$1 && shift
    while test "${arg:0:1}" = -; do # handle option...
        case $arg in
            -H | --no-hidden)   NO_HIDDEN=1;    opt="$opt -H" ;;
            -q | --quiet)       QUIET=1;        opt="$opt -q" ;;
            -v | --verbose)     VERBOSE=1;      opt="$opt -v" ;;
            -d | --debug)       DEBUG=1;        opt="$opt -d" ;;
            -h | --help)        exec awk '/^NAME$/,0' $0 ;;
            -a | --arg)         args="$args $1" && shift ;;
            -m | --method)      method=$1 && shift
                test $method || error --exit 101 "no method argument" ;;
            *) error --exit 102 "unsupported option $arg" ;;
        esac
        arg=$1 && shift # try again...
    done
<<<<<<< HEAD
=======
    }

## process argument list options:
arg=$1 && shift
unset method
while [ -n "$arg" -a "${arg:0:1}" = "-" ]; do # handle option ...

    if [ "$arg" = "-d" -o "$arg" = "--debug" ]; then
        DEBUG=1
        opt="$opt -d"

    elif [ "$arg" = "-v" -o "$arg" = "--verbose" ]; then
        VERBOSE=1
        opt="$opt -v"

    elif [ "$arg" = "-m" -o "$arg" = "--method" ]; then
        method=$1 && shift
        test $method || error --exit 111 "no method argument"

    elif [ "$arg" = "-a" -o "$arg" = "--arg" ]; then
        args="$args $1" && shift

    elif [ "$arg" = "-H" -o "$arg" = "--no-hidden" ]; then
        NO_HIDDEN=1
        opt="$opt -H"

    elif [ "$arg" = "-S" -o "$arg" = "--not-strict" ]; then
        NOT_STRICT=1
        opt="$opt -S"

    elif [ "$arg" = "-q" -o "$arg" = "--quiet" ]; then
        QUIET=1
        opt="$opt --quiet"

    elif [ "$arg" = "-h" -o "$arg" = "--help" ]; then # show manpage:
        exec /usr/bin/awk '/^NAME$/{ok=1}ok' $0
>>>>>>> 739b5b56
    
    test -z "$arg" && error --exit 103 "no object specified"
    
    test $method && { ## dispatch method from -m or --method option on objects:
        while [ $arg ]; do
            if [ ${arg/=} != $arg ]; then # tag=value form detected
                args="$args $arg"
            else
                test $VERBOSE &&
                    echo $0 $opt $arg.$method $args
                $0 $opt $ob.$method $args ||
                    error --exit 104 "failed in $arg.$method"
            fi
            arg=$1 && shift
        done
        exit
        }
    
    test ${arg/.//} = $arg && # no dot found, so exec as ..method in 'self' object
        exec $0 ..$arg "$@"
    
    ## parse the method and object from the object.method specification:
    TOB_method=${arg##*.}
    TOB_object=${arg%.*}
    
    ## count and remove 'super' modifier(s) if at end of object:
    declare -i super=0
    while test "${TOB_object: -6}" = ".super"; do
        TOB_object=${TOB_object%.super}
        super+=1
    done
<<<<<<< HEAD

    test -n "$TOB_object" ||
        error --exit 105 "no object parsed from $arg with method $TOB_method"
    
    test -n "$TOB_method" ||
        error --exit 106 "no method parsed from $arg, object $TOB_object"
    
    ## resolve_object() may change directories, so store caller's location:
    TOB_caller_path=$PWD

    test -n "$DEBUG" && { # all of these should now be set:
        warn DEBUG: TOB_object=$TOB_object
        warn DEBUG: TOB_method=$TOB_method
        warn DEBUG: super count: $super
        warn DEBUG: TOB_caller_path=$TOB_caller_path
        warn DEBUG: "args1='$args' args2='$*'"
        }
    
    # resolve_object() should set TOB_type, TOB_path_to_object
    resolve_object $TOB_object
    return_status=$?
    case $return_status in
    1)  error --exit 111 failed to cd to $TOB_object at $TOB_path_to_object ;;
    2)  error --exit 112 $TOB_object at $TOB_path_to_object is $TOB_type ;;
    3)  error --exit 113 broken symlink: $TOB_object at $TOB_path_to_object ;;
    4)  error --exit 114 no $TOB_object type at $TOB_path_to_object ;;
    5)  error --exit 115 "hidden element or elements ($hidden) in $obspec" ;;
    6)  test -z "$TOBLIB_NOT_OBJECT" ||
            error --exit 116 failed to resolve $TOB_object
        # ok to try to resolve tob library class as object
        # first dot-delimited element must exist as a directory
        prefix=${TOB_object%%.*}
        for toblib in $TOBLIB; do
            test -d $toblib/$prefix/ || continue
            exec $0 $toblib/$TOB_object.$TOB_method 
            # to fix: the above exec call is missing args...
        done
        error --exit 117 failed to resolve $TOB_object
        ;;
    esac

    ## a couple of assertion checks, probably redundant:
    test -n "$TOB_type" ||
        error --exit 118 failed to resolve $TOB_object type
    test -n "$TOB_path_to_object" ||
        error --exit 119 failed to resolve path to $TOB_object
    
    test -n "$DEBUG" && { # all of these should now be set:
        warn DEBUG: TOB_type=$TOB_type
        warn DEBUG: TOB_path_to_object=$TOB_path_to_object
        }
    
    # resolve_paths() builds arrays: types and paths, recursing on mixins
    # - first of 2 args is the object, not class, may include mixins
    # - types array is 1:1 with path after skipping paths[0]
    declare -a types mpaths apaths
    resolve_paths . $TOB_type

    test "$types" || {
        test "${#apaths[@]}" -gt 1 &&
            error --exit 120 prototype but no type resolved for $TOB_object
        error --exit 121 no type or prototype resolved for $TOB_object
        }

    # arrays may have duplicate entries, so leave only the last such entry
    cull_duplicate_paths
    
    ## export thinobject variables
    export TOB_object
    export TOB_method
    export TOB_type
    export TOB_class_path
    export TOB_caller_path
    export TOB_caller_path_to_object=$TOB_path_to_object
    
    ## export thinobject utility functions
    export -f TOB_resolve_method_path
    export -f TOB_get_attr
    
    # create pseudo-arrays for export, with colon as delimiter:
    save_IFS="$IFS"
    IFS=:
    export TOB_search_paths="${apaths[*]}"
    export TOB_method_paths="${mpaths[*]}"
    export TOB_type="${types[*]}"
    IFS="$save_IFS"
    
    test -n "$DEBUG" && {
        warn DEBUG: TOB_search_paths=$TOB_search_paths
        warn DEBUG: TOB_method_paths=$TOB_method_paths
        warn DEBUG: TOB_type=$TOB_type
        }
    
    resolve_method_path $TOB_method &&
        exec $TOB_method_path $args "$@"
    
    ## no executable method was resolved, so try some built-ins:
    
    test $TOB_method = path && {
        test -z "$*" && echo $TOB_path_to_object/
        for arg in $*; do
            test -e $arg ||
                error --exit 121 $arg not found
            echo $TOB_path_to_object/$arg
        done
=======
    exit
    }

test ${arg/.//} = $arg && # no dot found, so exec as ..method in 'self' object
    exec $0 ..$arg "$@"

## parse the method and object from the object.method specification:
TOB_method=${arg##*.}
TOB_object=${arg%.*}

## initialize method superizer:
super=0

# if called with object.super.method, ob=object.super, so fix this...
while test ${TOB_object%.super} != $TOB_object; do
    TOB_object=${TOB_object%.super}
    super=$(($super+1))
done

test -n "$TOB_object" ||
    error --exit 116 "no object parsed from $arg with method $TOB_method"

test -n "$TOB_method" ||
    error --exit 117 "no method parsed from $arg, object $TOB_object"


## the next method will change directories, so store caller's location:
TOB_caller_path=$PWD

resolve_and_chdir_into_object $TOB_object
return_code=$?

if test $return_code = 1; then
    error --exit 118 failed to resolve object: $TOB_object


elif test $return_code = 2; then
    find_default_file_class
    TOB_class_path=$TOB_FILE_CLASS
    warn pwd is $PWD
    warn query object was $TOB_object
    warn file object is $TOB_file_object
    error --exit 119 $TOB_object resolved to a file ... how to handle it?

elif test -n "$last_classlink"; then
  # warn object $TOB_object is a thinobject
  # warn last_classlink is $last_classlink
    TOB_class_path=./$classlink
else
  # warn object $TOB_object is a directory
    find_default_directory_class
    TOB_class_path=$TOB_DIRECTORY_CLASS
fi

test -n "$DEBUG" && {
    warn DEBUG: TOB_object=$TOB_object
    warn DEBUG: TOB_method=$TOB_method
    warn DEBUG: TOB_path_to_object=$TOB_path_to_object
    warn DEBUG: TOB_caller_path=$TOB_caller_path
    }

test -n $TOB_class_path || 
    error --exit 120 no object path resolved from $TOB_object

test -n "$DEBUG" && {
    warn DEBUG: TOB_path_to_object=$TOB_path_to_object
    warn DEBUG: TOB_class_path=$TOB_class_path
    }

test -n "$DEBUG" &&
    warn DEBUG: args1=\'$args\' args2=\'$*\'
    
# follow_paths() recursively builds the paths array starting with argument path
paths=()
follow_paths . $TOB_class_path
# paths array now constains the full inheritance path-set, may have duplicates

check_paths
# arrays: paths, method_paths, class_names are defined (may be sparse)

## export thinobject variables
export TOB_object
export TOB_method
export TOB_class_path
export TOB_caller_path
export TOB_caller_path_to_object=$TOB_path_to_object

## export thinobject utility functions
export -f TOB_resolve_method_path
export -f TOB_get_attr


# create pseudo-arrays for export:
save_IFS="$IFS"
IFS=:
export TOB_search_paths="${paths[*]}"
export TOB_method_paths="${method_paths[*]}"
export TOB_type="${class_names[*]}"
IFS="$save_IFS"

test -n "$DEBUG" && {
    warn DEBUG: TOB_search_paths=$TOB_search_paths
    warn DEBUG: TOB_method_paths=$TOB_method_paths
    warn DEBUG: TOB_type=$TOB_type
    }

resolve_method_path $TOB_method &&
    exec $TOB_method_path $args "$@"

## no executable method was resolved, so try some built-ins:

test $TOB_method = path && {
    test -z "$*" && echo $TOB_path_to_object/
    for arg in $*; do
        test -e $arg ||
            error --exit 121 $arg not found
        echo $TOB_path_to_object/$arg
    done
    exit
    }

test "$TOB_method" = "type" &&
    echo $TOB_type &&
>>>>>>> 739b5b56
        exit
        }
    
    test "$TOB_method" = "type" &&
        echo $TOB_type &&
            exit
    
    ## no method was found, so check for _default method...
    
    for path in ${mpaths[@]}; do
        ## ASSERT: class exists
        test -e $path/_default && {
            test -x $path/_default && {
              # warn DEBUG tob: exec $path/_default $TOB_object $TOB_method $*
                exec $path/_default $TOB_method "$@"
                }
            ## ASSERT: _default exists but is not executable
            ## maybe it can contain a recipe to be executed?
            error --exit 122 'non-executable _default "method" found'
            }
    done
    
    error --exit 123 "no method $TOB_method found"
    } # end main()

main "$@"

exit 47 # should not happen

## manpage follows
NAME
    tob -- parse and resolve object.method, invoke method in object directory

SYNOPSIS
    tob [OPTIONS] object.method [METHOD_OPTIONS] [ARGUMENTS]
    tob -m method [-a arg]... object...

DESCRIPTION
    Thinobject strives to achieve object oriented programming and data
    management directly on the filesystem, in a language-independent way.
    Methods are executable programs, written in any language.  Thinobject
    uses a symlink, .^ or ^, to a class directory (or handler).  Methods
    and attributes are searched for along the chain of class links.

EXIT VALUE
    Exit value should be 0 if no error occurred, but should have a value
    from 101 to 123 if there was an error.  The numbers are assigned
    sequentially in the tob script, and for now that's the only documentation
    for what specific values mean.

OPTIONS
    -d
    --debug
    turn on debug output

    -v
    --verbose
    turn on verbose output

    -m M
    --method M
    apply method M to the following list of objects    

    -a ARGS...
    --arg ARGS...
    provide arguments; useful in conjunction with the --method option

    -h
    --help
    show this help screen (manpage)

    -q
    --quiet
    suppress output to stderr on errors
    
OBJECT CREATION
    Use tob-new to create objects.

BUILT-IN METHODS
    path
        output the object directory path

    type
        output the class hierarchy

    foo [ARG]...
        if no method ``foo'' is found in the class hierarchy, search
        for a LIST property (@foo) or a DICTIONARY property (%foo)
        and treat this pseudo method as an ``accessor'' of that property.

PROPERTIES
    The thinobject system uses ordinary files and directories in the
    filesystem, so the contents of an object is arbitrary.  It may be
    convenient/helpful to think of the contents of an object as its
    ``properties'', if only to distinguish them from otherwise ordinary
    files (which they really are).

    Special meaning is applied to certain files, as follows:

    ^
    .^
    symlink to the parent class

    ^foo
    .^foo
    symlink to a mixin class


SEARCH PATHS
    tob prepares a search path for methods and one for attributes.
    These differ mainly in that methods are not resolved in the object,
    while attributes may be.

    Mixin classes are searched before the parent class, in lexical 
    order.  Common ancestor classes are searched last. 

EXPORTED VARIABLES
    TOB_object -- the object name as passed to the thinob enabler

    TOB_method -- the invoked method

    TOB_type -- the nominal class name

    TOB_class_path -- the class directory or handler path

    TOB_object_path -- the fully resolved object name

    TOB_search_paths -- search paths for object attributes

    TOB_method_paths -- search paths for object methods

    TOB_caller_path

    TOB_caller_path_to_object

    TOB_path_to_object

EXPORTED FUNCTIONS
    TOB_resolve_method_path
    TOB_get_attr

   output format is: $TOB_object.$TOB_method: ARGUMENTS...

SEE ALSO
    tob-new --help
    tob-del --help
    Ideally, each thinobject class will provide a help method, and a
    --help option to each of its methods.

BUGS
    This is an experimental system.

    Not sure the --quiet option is working quite right...

    Should document all exit values.

AUTHOR
    Ken.Irving@alaska.edu (c) 2007-2010
